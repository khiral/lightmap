//go:generate goversioninfo -icon=lightmap.ico

package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"strings"
)

func createEvent(cD int, lI int) (int, int) {
	eV := 0
	eT := 0

	switch cD {
	case 0, 2, 4, 6:
		eV = 7
	case 1, 3, 5, 7, 8:
		eV = 3
	default:
		eV = 0
	}

	switch lI {
	case 0:
		eT = 2
	case 1:
		eT = 0
	case 2:
		eT = 3
	case 3:
		eT = 4
	default:
		eT = 0
	}

	return eV, eT
}

func dup_count(list []float64) map[float64]int {

	duplicate_frequency := make(map[float64]int)

	for _, item := range list {
		// check if the item/element exist in the duplicate_frequency map

		_, exist := duplicate_frequency[item]

		if exist {
			duplicate_frequency[item] += 1 // increase counter by 1 if already in the map
		} else {
			duplicate_frequency[item] = 1 // else start counting from 1
		}
	}

	return duplicate_frequency
}

func MinMax(array []float64) (float64, float64) {
	var max float64 = array[0]
	var min float64 = array[0]
	for _, value := range array {
		if max < value {
			max = value
		}
		if min > value {
			min = value
		}
	}
	return min, max
}

func main() {
	if len(os.Args) < 2 {
		fmt.Println("Missing parameter, provide file name!")
		return
	}
	data, err := ioutil.ReadFile(os.Args[1])
	if err != nil {
		fmt.Println("Can't read file:", os.Args[1])
		panic(err)
	}

	type beatmapEvent struct {
		Time  float64 `json:"_time"`
		Type  int     `json:"_type"`
		Value int     `json:"_value"`
	}

	type beatmap struct {
		Version        string         `json:"_version"`
		BeatsPerMinute float64        `json:"_beatsPerMinute"`
		BeatsPerBar    int            `json:"_beatsPerBar"`
		NoteJumpSpeed  int            `json:"_noteJumpSpeed"`
		Shuffle        int            `json:"_shuffle"`
		ShufflePeriod  float64        `json:"_shufflePeriod"`
		Events         []beatmapEvent `json:"_events"`
		Notes          []struct {
			Time         float64 `json:"_time"`
			LineIndex    int     `json:"_lineIndex"`
			LineLayer    int     `json:"_lineLayer"`
			Type         int     `json:"_type"`
			CutDirection int     `json:"_cutDirection"`
		} `json:"_notes"`
		Obstacles []struct {
			Time      float64 `json:"_time"`
			LineIndex int     `json:"_lineIndex"`
			Type      int     `json:"_type"`
			Duration  float64 `json:"_duration"`
			Width     int     `json:"_width"`
		} `json:"_obstacles"`
	}

	var bm beatmap

	json.Unmarshal(data, &bm)

	var songlength float64
	songlength = 0
	for i := 0; i < len(bm.Notes); i++ {
		var notetime float64

		notetime = bm.Notes[i].Time
		if notetime > songlength {
			songlength = notetime
		}
	}

	var min1 float64
	if len(bm.Events) > 0 {
		var eventtimes []float64
		for i := 0; i < len(bm.Events); i++ {
			if bm.Events[i].Value == 0 {
				// we have an off, record the time
				eventtimes = append(eventtimes, bm.Events[i].Time)
			}
		}

		dup_map := dup_count(eventtimes)
		bm.Events = nil
		if len(dup_map) > 0 {
			var possiblemarker []float64

			for k, v := range dup_map {
				if v == 7 {
					possiblemarker = append(possiblemarker, k)
				}
			}
			if len(possiblemarker) > 0 {
				min1, _ = MinMax(possiblemarker)
				var flipflop bool
				flipflop = true

				for si := min1; si <= songlength; si += 8 {
					if songlength-si < 8 {
						if flipflop == true {
							bm.Events = append(bm.Events, beatmapEvent{si, 1, 7})
							flipflop = false
						} else {
							bm.Events = append(bm.Events, beatmapEvent{si, 1, 3})
							flipflop = true
						}
					} else {
						if flipflop == true {
							bm.Events = append(bm.Events, beatmapEvent{si, 1, 5})
							bm.Events = append(bm.Events, beatmapEvent{si - 1, 1, 3})
							flipflop = false
						} else {
							bm.Events = append(bm.Events, beatmapEvent{si, 1, 1})
							bm.Events = append(bm.Events, beatmapEvent{si - 1, 1, 7})
							flipflop = true
						}
					}

					bm.Events = append(bm.Events, beatmapEvent{si, 8, 0})
				}
			}
		}
	}

	//do normal notes

	for i := 0; i < len(bm.Notes); i++ {
		var eV int
		var eT int

		eV, eT = createEvent(bm.Notes[i].CutDirection, bm.Notes[i].LineIndex)

		bm.Events = append(bm.Events, beatmapEvent{bm.Notes[i].Time, eT, eV})
	}

	fixedJson, _ := json.Marshal(bm)
	backupName := (strings.TrimSuffix(os.Args[1], path.Ext(os.Args[1]))) + "_OLD.json"
	os.Rename(os.Args[1], backupName)
	err = ioutil.WriteFile(os.Args[1], fixedJson, 0644)
}
